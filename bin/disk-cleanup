#!/bin/bash

# Disk Space Cleanup Script
# Modular cleanup orchestrator that runs various cleanup commands

set -e

# Configuration
LOG_FILE="$HOME/.notes/cleanup.log"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MODULES_DIR="$SCRIPT_DIR/cleanup-modules"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Parse command line arguments
MODE="conservative"
SPECIFIC_MODULE=""
DRY_RUN=false

show_usage() {
    cat <<EOF
Usage: disk-cleanup [OPTIONS]

Options:
    --aggressive        Run cleanup in aggressive mode (removes more data)
    --module MODULE     Run only the specified module (homebrew, docker, node, python, rust, xcode)
    --dry-run          Show what would be cleaned without actually cleaning
    --help             Show this help message

Examples:
    disk-cleanup                                # Run all modules in conservative mode
    disk-cleanup --aggressive                   # Run all modules in aggressive mode
    disk-cleanup --module rust                  # Only run Rust cleanup
    disk-cleanup --module rust --aggressive     # Aggressive Rust cleanup only
    disk-cleanup --dry-run                      # Preview what would be cleaned

Available modules:
    homebrew    - Homebrew packages and cache
    docker      - Docker containers, images, networks, volumes
    node        - npm, yarn, pnpm caches
    python      - pip, UV, pytest, puppeteer caches
    rust        - Rust target directories and cargo cache
    xcode       - Xcode simulators, derived data, old versions
    flox        - Flox logs across all projects
    timemachine - Time Machine local snapshots
EOF
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --aggressive)
            MODE="aggressive"
            shift
            ;;
        --module)
            SPECIFIC_MODULE="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Function to log message
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" | tee -a "$LOG_FILE"
}

# Function to run command with logging
run_cleanup() {
    local description="$1"
    local command="$2"

    log_message "Starting: $description"

    if [ "$DRY_RUN" = true ]; then
        log_message "[DRY RUN] Would run: $command"
        return 0
    fi

    if eval "$command"; then
        log_message "Completed: $description"
    else
        log_message "Failed: $description"
    fi

    echo
}

# Export functions and variables for modules to use
export -f log_message
export -f run_cleanup
export LOG_FILE
export DRY_RUN

# Capture disk space before cleanup (in KB for accurate calculations)
if [ "$DRY_RUN" = false ]; then
    SPACE_BEFORE=$(df -k /System/Volumes/Data | tail -1 | awk '{print $3}')
fi

# Start cleanup
log_message "Starting disk cleanup (mode: $MODE)..."

if [ "$DRY_RUN" = true ]; then
    log_message "DRY RUN MODE - No actual changes will be made"
fi

# Function to run a cleanup module
run_module() {
    local module_name="$1"
    local module_file="$MODULES_DIR/${module_name}.sh"

    if [ -f "$module_file" ]; then
        log_message "Running module: $module_name"
        # shellcheck source=/dev/null
        source "$module_file"
        "cleanup_${module_name}" "$MODE"
    else
        log_message "Module not found: $module_name"
    fi
}

# Run specific module or all modules
if [ -n "$SPECIFIC_MODULE" ]; then
    run_module "$SPECIFIC_MODULE"
else
    # Run all modules in order
    run_module "homebrew"
    run_module "node"
    run_module "docker"
    run_module "python"
    run_module "xcode"
    run_module "rust"

    # Flox logs cleanup (not in a module yet - inline for now)
    log_message "Running Flox logs cleanup..."
    if [ -d "$HOME/dev/posthog/posthog/.flox/log" ]; then
        run_cleanup "Flox logs cleanup" "rm -rf ~/dev/posthog/posthog/.flox/log/*"
    fi

    # General flox logs cleanup in all projects
    find "$HOME/dev" -name ".flox" -type d 2>/dev/null | while read -r flox_dir; do
        if [ -d "$flox_dir/log" ] && [ "$(find "$flox_dir/log" -type f | wc -l)" -gt 0 ]; then
            run_cleanup "Flox logs cleanup in $(dirname "$flox_dir")" "rm -rf '$flox_dir/log'/*"
        fi
    done

    # Time Machine local snapshots cleanup
    log_message "Running Time Machine cleanup..."
    run_cleanup "Remove Time Machine local snapshots" "sudo tmutil deletelocalsnapshots /"
fi

log_message "Disk cleanup completed"

# Show disk usage and reclaimed space after cleanup
if [ "$DRY_RUN" = false ]; then
    # Capture disk space after cleanup
    SPACE_AFTER=$(df -k /System/Volumes/Data | tail -1 | awk '{print $3}')

    # Calculate space reclaimed (before - after = freed space)
    SPACE_RECLAIMED=$((SPACE_BEFORE - SPACE_AFTER))

    # Convert to human readable format
    if [ "$SPACE_RECLAIMED" -gt 1048576 ]; then
        RECLAIMED_DISPLAY=$(echo "scale=2; $SPACE_RECLAIMED / 1048576" | bc)" GB"
    elif [ "$SPACE_RECLAIMED" -gt 1024 ]; then
        RECLAIMED_DISPLAY=$(echo "scale=2; $SPACE_RECLAIMED / 1024" | bc)" MB"
    else
        RECLAIMED_DISPLAY="${SPACE_RECLAIMED} KB"
    fi

    echo
    echo "═══════════════════════════════════════════════════════════"
    echo "Total space reclaimed: $RECLAIMED_DISPLAY"
    echo "Free space available: $(df -h /System/Volumes/Data | tail -1 | awk '{print $4}')"
    echo "═══════════════════════════════════════════════════════════"
fi
